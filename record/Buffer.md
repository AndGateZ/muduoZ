# 动态缓冲-Buffer
## 使用场景
1. 发送：outputbuffer
- 场景：发送100kb数据，write（）受限于接收端滑动窗口，接收端只接收80kb，20kb未发送
- buffer功能：避免因为发送不完整导致程序阻塞，将剩余数据存入buffer（后来新的数据以追加形式放入buffer），注册pollout事件，一旦监听到socket可写（缓冲区可用空间大于写低水位）立刻写入
2. 接收：inputBuffer
- 场景：一份2KB数据可能分块到达的方式有2^N-1种
- buffer功能：非阻塞的收取每次收到了分块消息，必须一次性把socket里的数据读完，如果是固定buffer就只能读一小块，且反复触发pollin事件，动态buffer可以一次收完socket缓冲区内的数据，pollin事件只触发一次
- 注意：消息接收和消息处理分开，将分块消息处理为完整的消息于上层回调实现，buffer只负责消息接收
<br /> 

## 设计思路
1. 方案1-string：
- inputbuffer：一次性append追加完所有的数据（阻塞），读完设置读监听，完成后clear清空
- outputbuffer：一次性写完所有的数据（阻塞），写完设置写监听，完成后这个string将重复使用  
- 缺点：主要是追加速度慢
  - 追加是new空间，拷贝很慢，clear（）是第一位修改为\0很快  
  - 在缓冲区固定而数据很大的时候，read还是会调用很多次，利用临时数组来解决这个问题  
2. Char[]+extrabuf临时栈上空间（采纳）
- inputbuffer：数据写入buffer，如果超出了则扩容（muduo：大多数时候缓冲区使用率很低）
- 优点：不用清空，挪指针就好了，维护写入数据大小的变量；在LT模式下可减少系统调用
- 缺点：因为ET非阻塞，需要反复收取，比LT多一次系统调用，但是少了epoll_wait，所以还是划算的
